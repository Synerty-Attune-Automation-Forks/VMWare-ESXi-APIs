
pwsh -NonInteractive -NoProfile -Command - <<'EOF'
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

Import-Module VMware.VimAutomation.Core

function Split-StringIntoChunks($str, $chunkSize) {
    for ($i = 0; $i -lt $str.Length; $i += $chunkSize) {
        $str.Substring($i, [Math]::Min($chunkSize, $str.Length - $i))
    }
}

$WIN_PS1_DROP_DIR = "{automationWorkerLinuxBaseDirectory}/build-{newVmNode.fqn}/post_install_wim"

function Make-AutounattendCommandsFromFile() {
    # NOTE: The Powershell steps in this function took 30 hours to develop
    # due to all the limitations in autounattend commands.
    # These limitations include:
    #
    # * Command length, about 300 is a nice place, or the commands just don't run
    # * Quotes, You can have double quotes, but not nested, no other quotes
    # * Syntax, This is interpreted by powershell on the command line, which
    #      will interpret things like > % |, etc
    # * Writing to files - Powershell seems unable to write to a file using
    #      set-content, etc.
    #
    # At this point getting autounattend commands to is more like developing 
    #     an exploit.

    if ( -not (Test-Path $WIN_PS1_DROP_DIR) ) {
        Write-Host "Skipping inclusion of autounattend scripts as there are no *.ps1 files in |$WIN_PS1_DROP_DIR|";
        return @(
            "Write-Host 'SKIPPING: No PS1 files provied'"
        )
    }
        
    $psFromFiles = @(
    )

    # Get the files in the directory, filtered by extension
    Get-ChildItem -Path $WIN_PS1_DROP_DIR -Filter "*.ps1" |
        Sort-Object -Property Name |
        ForEach-Object {
            $data = Get-Content -Path $_.FullName -Raw
            $psFromFiles += ""
            $psFromFiles += "###########"
            $psFromFiles += "# From file: $(Split-Path $_.FullName -Leaf)"
            # Add every line as an item to the array, and fix line endings
            $psFromFiles += @($data -split "`r?`n")
    }

    # Print this for debugging
    Write-Host "We have $($psFromFiles.Length) Lines"
    Write-Host "The powershell we'll run is:"
    $psFromFiles  | ForEach-Object {
        Write-Host $_  
    }

    # Concatenate the contents of the files
    $joinedPsFromFiles = $psFromFiles -Join "`r`n"
    Write-Host "Our PS1 file will be $($joinedPsFromFiles.Length) long"

    # Encode the contents as base64 so we don't have to worry about quotes
    $encodedEnableWinRmPs1 = [Convert]::ToBase64String(
        [System.Text.Encoding]::Unicode.GetBytes($joinedPsFromFiles)
    )

    $attuneB64Path = 'C:\Users\Public\attune.b64'
    $attunePs1Path = 'C:\Users\Public\attune.ps1'

    # Start with a command to create the attune.b64 file
    $enableWinRmPs1 = @(
        "cmd /c copy nul $attuneB64Path"
    )

    # Split the base64 into chunks, and append them to attune.b64
    # The autounattend commands fail if they are long
    Split-StringIntoChunks $encodedEnableWinRmPs1 200 |
        ForEach-Object {
        $enableWinRmPs1 += "cmd /c `"echo $_ >> $attuneB64Path`" "
    }

    # Create the attune.ps1 file from the attune.b64 file
    $enableWinRmPs1 += "cmd /c copy nul $attunePs1Path"
    $enableWinRmPs1 += "cmd /c echo `$h=gc ^`"$attuneB64Path^`"^; [Text.Encoding]::Unicode.GetString([Convert]::FromBase64String(`$h)) | powershell.exe -NoProfile -Command - >> $attunePs1Path"

    # Finally, Run the Powershell
    $enableWinRmPs1 += "powershell.exe -ExecutionPolicy Bypass -File $attunePs1Path "


    # Print this for debugging
    Write-Host "We have $($enableWinRmPs1.Length) Commands"
    Write-Host "The autounattend commands we'll run are:"
    $enableWinRmPs1  | ForEach-Object {
        Write-Host $_.Length
        Write-Host $_
    }

    return $enableWinRmPs1;
}

# Connect to server
Connect-VIServer {vmwareVcenterServer.ip} `
    -User {vmwareVcenterUser.user} `
    -Password {vmwareVcenterUser.password}

# Get the original spec
$originalSpec = Get-OSCustomizationSpec `
    -Name "{osCustomizationSpecName.value}"

# Delete the tempory copy if it exists
Get-OSCustomizationSpec `
    -Name "{newVmNode.fqn}_spec" `
    -ErrorAction SilentlyContinue |
    Remove-OSCustomizationSpec -Confirm:$false

# Create a temporary copy
$tempSpec = New-OSCustomizationSpec `
    -Name "{newVmNode.fqn}_spec" `
    -OSCustomizationSpec $originalSpec

# Validate inputs for
if ( $tempSpec.OSType -eq 'Windows' ) {
    $hostname = "{newVmNode.hostname}"
    Write-Host "CHECKING: Hostname '$hostname' ($($hostname.Length)) is no more than 15 characters."
    if ($hostname.Length -gt 15) {
        Write-Host "ERROR: Hostname '$hostname' is longer than 15 characters. This will cause the create from template to fail."
        exit 1
    }
}

if ( $tempSpec.OSType -eq 'Windows' ) {
    echo "Customising the specification for windows"
    if ( -not "{newVmSubnet.dns2}" ) {
        $dns = "{newVmSubnet.dns1}"
    } else {
        $dns = "{newVmSubnet.dns1}", "{newVmSubnet.dns2}"
    }

    $enableWinRmPs1 = Make-AutounattendCommandsFromFile

    Get-OSCustomizationNicMapping -Spec $tempSpec |
        Set-OSCustomizationNicMapping `
            -IpMode UseStaticIP `
            -IPAddress {newVmNode.ip} `
            -Subnetmask {newVmSubnet.netmask} `
            -DefaultGateway {newVmSubnet.gateway} `
            -Dns $dns

    # Modify the temp spec
    Set-OSCustomizationSpec -Spec $tempSpec `
        -Name $tempSpec.Name `
        -NamingScheme Fixed `
        -NamingPrefix "{newVmNode.hostname}" `
        -GuiRunOnce $enableWinRmPs1

} else {
    echo "Customising the specification for not windows"

# Modify the temp spec
    Set-OSCustomizationSpec -Spec $tempSpec `
        -Name $tempSpec.Name `
        -NamingScheme Fixed `
        -NamingPrefix "{newVmNode.hostname}" `


    Get-OSCustomizationNicMapping -Spec $tempSpec |
        Set-OSCustomizationNicMapping `
            -IpMode UseStaticIP `
            -IPAddress {newVmNode.ip} `
            -Subnetmask {newVmSubnet.netmask} `
            -DefaultGateway {newVmSubnet.gateway}

}

$name = "{newVmNode.fqn}"
$cpuCount = {vmCpuCount}
$memInMb = {vmRamSizeGb}*1024
$networkName = "{vmNetworkName}"

if ( "{vmwareEsxiHost.fqn}" -eq "{vmwareVcenterNode.fqn}" ) {
    Write-Host "We're talking to the ESXi host, don't pass the -VMHost arg"
    $storagePool = "{vmStoragePoolName}"
    # Deploy the VM with the modified spec
    $vm = New-VM `
        -Template "{vmwareVmTemplateName.value}" `
        -Name "$name" `
        -Datastore "$storagePool" `
        -NetworkName "$networkName" `
        -OSCustomizationSpec $tempSpec

} else {
    Write-Host "We're talking to a vCenter server, pass the -VMHost arg"
    $storagePool = Get-VMHost -Name '{vmwareEsxiHost.fqn}' |
        Get-Datastore -Name '{vmStoragePoolName}'

        # Deploy the VM with the modified spec
    $vm = New-VM `
        -Template "{vmwareVmTemplateName.value}" `
        -VMHost "{vmwareEsxiHost.fqn}" `
        -Name "$name" `
        -Datastore "$storagePool" `
        -NetworkName "$networkName" `
        -OSCustomizationSpec $tempSpec

}

if ($? -eq $false) {
    Write-Host "Error: Failed to create VM."
    exit 1
}

$vm | Set-VM `
    -CoresPerSocket $cpuCount `
    -NumCpu $cpuCount `
    -MemoryMB $memInMb `
    -Confirm:$false

# Clean up
Remove-OSCustomizationSpec -Spec $tempSpec -Confirm:$false

# Disconnect from vCenter
Disconnect-VIServer -Confirm:$false

EOF
